<!DOCTYPE html>
<html lang="pl" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rcoin Fund dApp v4.6 (Finalne Poprawki)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .btn {
            font-weight: bold;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s, transform 0.1s;
            width: 100%;
            cursor: pointer;
        }
        .btn:active {
            transform: scale(0.98);
        }
        .btn-blue { background-color: #3b82f6; color: white; }
        .btn-blue:hover { background-color: #2563eb; }
        .btn-red { background-color: #ef4444; color: white; }
        .btn-red:hover { background-color: #dc2626; }
        .tab-active { background-color: #3b82f6; color: white; }
        .tab-inactive { background-color: #3f3f46; color: #a1a1aa; }
        .tab-inactive:hover { background-color: #52525b; }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] { -moz-appearance: textfield; }
        .list-item {
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: #27272a;
            color: #d4d4d8;
        }
        .list-item-pending { border-left: 4px solid #facc15; }
        .list-item-ready { border-left: 4px solid #3b82f6; }
        .list-item-archived { border-left: 4px solid #a1a1aa; }
    </style>
</head>
<body class="bg-zinc-900 text-white flex justify-center items-center min-h-screen p-4">
    <div id="app" class="w-full max-w-2xl bg-zinc-800 p-6 rounded-xl shadow-lg border border-zinc-700">
        <!-- Status Message -->
        <div id="statusMessage" class="hidden fixed bottom-5 right-5 p-4 rounded-lg shadow-lg max-w-sm border-l-4">
            <div class="flex items-center">
                <svg id="statusSpinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p id="statusText"></p>
            </div>
        </div>

        <h1 class="text-3xl font-bold text-center text-blue-400 mb-6">Rcoin Fund dApp</h1>
        
        <!-- Account Info -->
        <div class="bg-zinc-700 p-4 rounded-lg mb-6 shadow-md">
            <h2 class="text-xl font-semibold mb-2 text-blue-300">Moje konto</h2>
            <p id="accountAddress" class="break-all text-sm text-gray-400">Adres: Ładowanie...</p>
            <p id="rcoinBalance" class="mt-2 text-lg">Twój bilans (Rcoin): Ładowanie...</p>
            <p id="usdcBalance" class="mt-1 text-lg">Twój bilans (USDC): Ładowanie...</p>
            <p id="totalAssets" class="mt-1 text-lg">Całkowita wartość aktywów (USDC): Ładowanie...</p>
            <p id="withdrawalDelay" class="mt-1 text-sm text-gray-400">Okres opóźnienia wypłaty: Ładowanie...</p>
        </div>

        <!-- Tabs -->
        <div class="flex justify-around bg-zinc-700 rounded-t-lg p-1">
            <button id="tabInstant" class="flex-1 py-2 px-4 text-center rounded-md tab-active transition-colors" onclick="app.switchTab('instant')">Wpłata & Natychmiastowa Wypłata</button>
            <button id="tabDelayed" class="flex-1 py-2 px-4 text-center rounded-md tab-inactive transition-colors" onclick="app.switchTab('delayed')">Wypłata z Opóźnieniem</button>
        </div>
        
        <!-- Tab Panels -->
        <div class="bg-zinc-700 p-4 rounded-b-lg shadow-md mb-6">
            <!-- Instant Panel -->
            <div id="instantWithdrawPanel">
                <!-- Deposit -->
                <div class="mb-6">
                    <label for="depositAmount" class="block text-sm font-medium text-gray-300 mb-2">Wpłać USDC</label>
                    <div class="flex items-center space-x-2">
                        <input type="number" id="depositAmount" placeholder="0.0" class="flex-1 p-3 rounded-md bg-zinc-900 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="depositBtn" class="btn btn-blue w-auto whitespace-nowrap">Wpłać</button>
                    </div>
                </div>

                <!-- Instant Withdraw -->
                <div>
                    <label for="instantWithdrawAmount" class="block text-sm font-medium text-gray-300 mb-2">Wypłać USDC (Natychmiastowa)</label>
                    <div class="flex items-center space-x-2">
                        <input type="number" id="instantWithdrawAmount" placeholder="0.0" class="flex-1 p-3 rounded-md bg-zinc-900 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="instantWithdrawBtn" class="btn btn-red w-auto whitespace-nowrap">Wypłać</button>
                    </div>
                    <p id="instantWithdrawFee" class="mt-2 text-xs text-gray-400">Opłata: 0%</p>
                </div>
            </div>

            <!-- Delayed Panel -->
            <div id="delayedWithdrawPanel" class="hidden">
                <!-- Request Delayed Withdraw -->
                <div class="mb-6">
                    <label for="delayedWithdrawAmount" class="block text-sm font-medium text-gray-300 mb-2">Wypłać USDC (Z opóźnieniem)</label>
                    <div class="flex items-center space-x-2">
                        <input type="number" id="delayedWithdrawAmount" placeholder="0.0" class="flex-1 p-3 rounded-md bg-zinc-900 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="requestWithdrawBtn" class="btn btn-blue w-auto whitespace-nowrap">Złóż wniosek</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Manager Panel -->
        <div id="managerPanel" class="hidden bg-zinc-800 p-6 rounded-xl shadow-lg border border-zinc-700 mb-6">
            <h2 class="text-2xl font-bold text-center text-red-400 mb-4">Panel Menedżera</h2>

            <!-- Manager Actions -->
            <div class="bg-zinc-700 p-4 rounded-lg mb-4">
                <h3 class="text-lg font-semibold mb-2 text-red-300">Akcje</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="updateOffChainBalance" class="block text-sm font-medium text-gray-300 mb-2">Aktualizuj bilans off-chain (USDC)</label>
                        <div class="flex items-center space-x-2">
                            <input type="number" id="updateOffChainBalance" placeholder="0.0" class="flex-1 p-3 rounded-md bg-zinc-900 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="updateOffChainBtn" class="btn btn-red w-auto whitespace-nowrap">Aktualizuj</button>
                        </div>
                    </div>
                    <div>
                        <label for="transferToFund" class="block text-sm font-medium text-gray-300 mb-2">Przelej do skarbca (USDC)</label>
                        <div class="flex items-center space-x-2">
                            <input type="number" id="transferToFund" placeholder="0.0" class="flex-1 p-3 rounded-md bg-zinc-900 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="transferToFundBtn" class="btn btn-red w-auto whitespace-nowrap">Przelej</button>
                        </div>
                    </div>
                    <div>
                        <label for="transferFromFund" class="block text-sm font-medium text-gray-300 mb-2">Przelej z skarbca (USDC)</label>
                        <div class="flex items-center space-x-2">
                            <input type="number" id="transferFromFund" placeholder="0.0" class="flex-1 p-3 rounded-md bg-zinc-900 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="transferFromFundBtn" class="btn btn-red w-auto whitespace-nowrap">Przelej</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Withdrawal Requests History -->
            <div class="bg-zinc-700 p-4 rounded-lg">
                <h3 class="text-lg font-semibold mb-2 text-blue-300">Historia wniosków o wypłatę</h3>
                
                <h4 class="text-md font-semibold mt-4 mb-2">Do odbioru:</h4>
                <ul id="unclaimedRequestsList"></ul>

                <h4 class="text-md font-semibold mt-4 mb-2">Oczekujące:</h4>
                <ul id="pendingRequestsList"></ul>
                
                <h4 class="text-md font-semibold mt-4 mb-2">Zakończone:</h4>
                <ul id="archivedRequestsList"></ul>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, addDoc, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase configuration and initialization
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        // Set log level for debugging
        setLogLevel('debug');

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Define contract addresses and ABIs
        const CONTRACT_ADDRESS_VAULT = "0x89C1aB6611c97034c4f3469B5658603B648d794C";
        const CONTRACT_ADDRESS_USDC = "0x409eA89004B2A8d06d4e138a2e5d590151125217";
        const ABI_VAULT = [
            "function totalAssets() view returns (uint256)",
            "function totalOffChainBalance() view returns (uint256)",
            "function asset() view returns (address)",
            "function previewDeposit(uint256 assets) view returns (uint256)",
            "function deposit(uint256 assets, address receiver) payable returns (uint256)",
            "function previewWithdraw(uint256 assets) view returns (uint256)",
            "function withdraw(uint256 assets, address receiver, address owner) returns (uint256)",
            "function instantWithdrawalFeeBps() view returns (uint16)",
            "function instantWithdrawal(uint256 assetsToRedeem)",
            "function requestDelayedWithdrawal(uint256 assetsToRedeem)",
            "function fulfillDelayedWithdrawal(address client)",
            "function cancelDelayedWithdrawal()",
            "function withdrawalDelayPeriod() view returns (uint256)",
            "function fundManager() view returns (address)",
            "function updateOffChainBalance(uint256 newBalance)",
            "function transferToFund(uint256 assets)",
            "function transferFromFund(uint256 assets)",
            "function withdrawalRequests(address) view returns (uint256 assets, uint256 timestamp)",
            "event InstantWithdrawal(address indexed client, uint256 assetsReceived, uint256 feePaid)",
            "event DelayedWithdrawalRequested(address indexed client, uint256 assetsToRedeem, uint256 unlockTime)",
            "event DelayedWithdrawalFulfilled(address indexed client, address indexed manager, uint256 assetsFulfilled)",
            "event DelayedWithdrawalCanceled(address indexed client)",
            "event OffChainBalanceUpdated(uint256 newBalance)",
            "event TransferToFund(uint256 assets)",
            "event TransferFromFund(uint256 assets)",
            "event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares)",
            "event Withdraw(address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares)",
            "event Mint(address indexed sender, address indexed owner, uint256 assets, uint256 shares)",
            "event Burn(address indexed sender, address indexed owner, uint256 assets, uint256 shares)"
        ];
        const ABI_USDC = [
            "function balanceOf(address account) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)"
        ];

        class DApp {
            constructor() {
                this.elements = {
                    app: document.getElementById('app'),
                    accountAddress: document.getElementById('accountAddress'),
                    rcoinBalance: document.getElementById('rcoinBalance'),
                    usdcBalance: document.getElementById('usdcBalance'),
                    totalAssets: document.getElementById('totalAssets'),
                    withdrawalDelay: document.getElementById('withdrawalDelay'),
                    tabInstant: document.getElementById('tabInstant'),
                    tabDelayed: document.getElementById('tabDelayed'),
                    instantWithdrawPanel: document.getElementById('instantWithdrawPanel'),
                    delayedWithdrawPanel: document.getElementById('delayedWithdrawPanel'),
                    depositAmount: document.getElementById('depositAmount'),
                    depositBtn: document.getElementById('depositBtn'),
                    instantWithdrawAmount: document.getElementById('instantWithdrawAmount'),
                    instantWithdrawBtn: document.getElementById('instantWithdrawBtn'),
                    instantWithdrawFee: document.getElementById('instantWithdrawFee'),
                    delayedWithdrawAmount: document.getElementById('delayedWithdrawAmount'),
                    requestWithdrawBtn: document.getElementById('requestWithdrawBtn'),
                    unclaimedRequestsList: document.getElementById('unclaimedRequestsList'),
                    pendingRequestsList: document.getElementById('pendingRequestsList'),
                    archivedRequestsList: document.getElementById('archivedRequestsList'),
                    managerPanel: document.getElementById('managerPanel'),
                    updateOffChainBalance: document.getElementById('updateOffChainBalance'),
                    updateOffChainBtn: document.getElementById('updateOffChainBtn'),
                    transferToFund: document.getElementById('transferToFund'),
                    transferToFundBtn: document.getElementById('transferToFundBtn'),
                    transferFromFund: document.getElementById('transferFromFund'),
                    transferFromFundBtn: document.getElementById('transferFromFundBtn'),
                    statusMessage: document.getElementById('statusMessage'),
                    statusText: document.getElementById('statusText'),
                    statusSpinner: document.getElementById('statusSpinner'),
                };

                this.state = {
                    signer: null,
                    contracts: {},
                    provider: null,
                    isManager: false,
                    withdrawalDelayPeriod: 0,
                };
            }

            async init() {
                this.showStatus("Łączenie z portfelem...", "loading");
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        await window.ethereum.request({ method: 'eth_requestAccounts' });
                        this.state.provider = new ethers.providers.Web3Provider(window.ethereum);
                        this.state.signer = this.state.provider.getSigner();

                        const vaultAddress = CONTRACT_ADDRESS_VAULT;
                        const usdcAddress = CONTRACT_ADDRESS_USDC;

                        this.state.contracts.vault = new ethers.Contract(vaultAddress, ABI_VAULT, this.state.signer);
                        this.state.contracts.usdc = new ethers.Contract(usdcAddress, ABI_USDC, this.state.signer);
                        
                        this.attachEventListeners();
                        await this.updateUI();
                        this.subscribeToEvents();
                        this.hideStatus();
                        console.log("DApp zainicjowany pomyślnie.");
                    } catch (error) {
                        console.error("Błąd podczas inicjalizacji:", error);
                        this.showStatus("Błąd połączenia z portfelem. Upewnij się, że masz zainstalowany MetaMask i jesteś na odpowiedniej sieci.", "error");
                    }
                } else {
                    this.showStatus("MetaMask nie wykryty. Proszę zainstalować.", "error");
                }
            }

            attachEventListeners() {
                this.elements.depositBtn.addEventListener('click', () => this.handleDeposit());
                this.elements.instantWithdrawBtn.addEventListener('click', () => this.handleInstantWithdrawal());
                this.elements.requestWithdrawBtn.addEventListener('click', () => this.handleDelayedWithdrawalRequest());
                this.elements.updateOffChainBtn.addEventListener('click', () => this.handleUpdateOffChainBalance());
                this.elements.transferToFundBtn.addEventListener('click', () => this.handleTransferToFund());
                this.elements.transferFromFundBtn.addEventListener('click', () => this.handleTransferFromFund());
            }

            subscribeToEvents() {
                if (this.state.contracts.vault) {
                    this.state.contracts.vault.on('Deposit', (sender, owner, assets, shares) => {
                        console.log(`Nowy depozyt od ${owner}: ${ethers.utils.formatUnits(assets, 6)} USDC, ${ethers.utils.formatUnits(shares, 18)} Rcoin`);
                        this.updateUI();
                    });
                    this.state.contracts.vault.on('Withdraw', (sender, receiver, owner, assets, shares) => {
                        console.log(`Wypłata dla ${receiver}: ${ethers.utils.formatUnits(assets, 6)} USDC, ${ethers.utils.formatUnits(shares, 18)} Rcoin`);
                        this.updateUI();
                    });
                    this.state.contracts.vault.on('DelayedWithdrawalRequested', (client, assetsToRedeem, unlockTime) => {
                        console.log(`Zgłoszono wniosek o opóźnioną wypłatę dla ${client}: ${ethers.utils.formatUnits(assetsToRedeem, 6)} USDC, odblokowanie o ${new Date(unlockTime.toNumber() * 1000)}`);
                        this.updateUI();
                    });
                    this.state.contracts.vault.on('DelayedWithdrawalFulfilled', (client, manager, assetsFulfilled) => {
                        console.log(`Wniosek o wypłatę dla ${client} został zrealizowany przez ${manager}, kwota ${ethers.utils.formatUnits(assetsFulfilled, 6)} USDC`);
                        this.updateUI();
                    });
                    this.state.contracts.vault.on('DelayedWithdrawalCanceled', (client) => {
                        console.log(`Wniosek o wypłatę dla ${client} został anulowany.`);
                        this.updateUI();
                    });
                }
            }

            async updateUI() {
                try {
                    const address = await this.state.signer.getAddress();
                    this.elements.accountAddress.innerText = `Adres: ${address}`;
                    
                    const [rcoinBalance, usdcBalance, totalAssets, withdrawalDelay, fundManagerAddress, instantFee] = await Promise.all([
                        this.state.contracts.vault.balanceOf(address),
                        this.state.contracts.usdc.balanceOf(address),
                        this.state.contracts.vault.totalAssets(),
                        this.state.contracts.vault.withdrawalDelayPeriod(),
                        this.state.contracts.vault.fundManager(),
                        this.state.contracts.vault.instantWithdrawalFeeBps()
                    ]);

                    this.state.withdrawalDelayPeriod = withdrawalDelay.toNumber();
                    this.state.isManager = address.toLowerCase() === fundManagerAddress.toLowerCase();

                    this.elements.rcoinBalance.innerText = `Twój bilans (Rcoin): ${ethers.utils.formatUnits(rcoinBalance, 18)} Rcoin`;
                    this.elements.usdcBalance.innerText = `Twój bilans (USDC): ${ethers.utils.formatUnits(usdcBalance, 6)} USDC`;
                    this.elements.totalAssets.innerText = `Całkowita wartość aktywów (USDC): ${ethers.utils.formatUnits(totalAssets, 6)} USDC`;
                    this.elements.withdrawalDelay.innerText = `Okres opóźnienia wypłaty: ${withdrawalDelay.toNumber()} sekund`;
                    this.elements.instantWithdrawFee.innerText = `Opłata: ${instantFee.toNumber() / 100}%`;
                    
                    if (this.state.isManager) {
                        this.elements.managerPanel.classList.remove('hidden');
                        this.loadWithdrawalRequestsHistory();
                    } else {
                        this.elements.managerPanel.classList.add('hidden');
                    }
                } catch (error) {
                    console.error("Błąd podczas aktualizacji UI:", error);
                    this.showStatus("Błąd ładowania danych", "error");
                }
            }

            async handleDeposit() {
                const amount = this.elements.depositAmount.value;
                if (!amount || isNaN(amount) || amount <= 0) {
                    this.showStatus("Podaj poprawną kwotę do wpłaty.", "error");
                    return;
                }
                this.showStatus("Wpłacanie...", "loading");
                try {
                    const usdcAmount = ethers.utils.parseUnits(amount, 6);
                    const signerAddress = await this.state.signer.getAddress();
                    
                    const allowance = await this.state.contracts.usdc.allowance(signerAddress, this.state.contracts.vault.address);
                    if (allowance.lt(usdcAmount)) {
                        this.showStatus("Wymagana akceptacja USDC...", "loading");
                        const txApprove = await this.state.contracts.usdc.approve(this.state.contracts.vault.address, ethers.constants.MaxUint256);
                        await txApprove.wait();
                    }

                    this.showStatus("Realizowanie wpłaty...", "loading");
                    const tx = await this.state.contracts.vault.deposit(usdcAmount, signerAddress);
                    await tx.wait();
                    this.showStatus("Wpłata zakończona sukcesem!", "success");
                    this.updateUI();
                } catch (error) {
                    console.error("Błąd podczas wpłaty:", error);
                    this.showStatus("Błąd wpłaty. Sprawdź konsolę.", "error");
                }
            }

            async handleInstantWithdrawal() {
                const amount = this.elements.instantWithdrawAmount.value;
                if (!amount || isNaN(amount) || amount <= 0) {
                    this.showStatus("Podaj poprawną kwotę do wypłaty.", "error");
                    return;
                }
                this.showStatus("Wypłacanie...", "loading");
                try {
                    const usdcAmount = ethers.utils.parseUnits(amount, 6);
                    const tx = await this.state.contracts.vault.instantWithdrawal(usdcAmount);
                    await tx.wait();
                    this.showStatus("Wypłata zakończona sukcesem!", "success");
                    this.updateUI();
                } catch (error) {
                    console.error("Błąd podczas natychmiastowej wypłaty:", error);
                    this.showStatus("Błąd natychmiastowej wypłaty. Sprawdź konsolę.", "error");
                }
            }

            async handleDelayedWithdrawalRequest() {
                const amount = this.elements.delayedWithdrawAmount.value;
                if (!amount || isNaN(amount) || amount <= 0) {
                    this.showStatus("Podaj poprawną kwotę do wypłaty.", "error");
                    return;
                }
                this.showStatus("Zgłaszanie wniosku...", "loading");
                try {
                    const usdcAmount = ethers.utils.parseUnits(amount, 6);
                    const tx = await this.state.contracts.vault.requestDelayedWithdrawal(usdcAmount);
                    await tx.wait();
                    this.showStatus("Wniosek o wypłatę zgłoszony pomyślnie!", "success");
                    this.updateUI();
                } catch (error) {
                    console.error("Błąd podczas zgłaszania wniosku o wypłatę:", error);
                    this.showStatus("Błąd zgłaszania wniosku. Sprawdź konsolę.", "error");
                }
            }

            async handleFulfillWithdrawal(clientAddress) {
                this.showStatus("Realizowanie wypłaty...", "loading");
                try {
                    const tx = await this.state.contracts.vault.fulfillDelayedWithdrawal(clientAddress);
                    await tx.wait();
                    this.showStatus("Wypłata zrealizowana pomyślnie!", "success");
                    this.loadWithdrawalRequestsHistory();
                } catch (error) {
                    console.error("Błąd podczas realizacji wypłaty:", error);
                    this.showStatus("Błąd realizacji. Sprawdź konsolę.", "error");
                }
            }

            async handleCancelWithdrawal() {
                this.showStatus("Anulowanie wniosku...", "loading");
                try {
                    const tx = await this.state.contracts.vault.cancelDelayedWithdrawal();
                    await tx.wait();
                    this.showStatus("Wniosek anulowany pomyślnie!", "success");
                    this.updateUI();
                } catch (error) {
                    console.error("Błąd podczas anulowania wniosku:", error);
                    this.showStatus("Błąd anulowania wniosku. Sprawdź konsolę.", "error");
                }
            }

            async handleUpdateOffChainBalance() {
                const newBalance = this.elements.updateOffChainBalance.value;
                if (!newBalance || isNaN(newBalance) || newBalance < 0) {
                    this.showStatus("Podaj poprawną kwotę.", "error");
                    return;
                }
                this.showStatus("Aktualizacja bilansu...", "loading");
                try {
                    const amount = ethers.utils.parseUnits(newBalance, 6);
                    const tx = await this.state.contracts.vault.updateOffChainBalance(amount);
                    await tx.wait();
                    this.showStatus("Bilans off-chain zaktualizowany!", "success");
                    this.updateUI();
                } catch (error) {
                    console.error("Błąd podczas aktualizacji bilansu:", error);
                    this.showStatus("Błąd aktualizacji. Sprawdź konsolę.", "error");
                }
            }

            async handleTransferToFund() {
                const amount = this.elements.transferToFund.value;
                if (!amount || isNaN(amount) || amount <= 0) {
                    this.showStatus("Podaj poprawną kwotę.", "error");
                    return;
                }
                this.showStatus("Przelewanie do skarbca...", "loading");
                try {
                    const usdcAmount = ethers.utils.parseUnits(amount, 6);
                    const signerAddress = await this.state.signer.getAddress();
                    const allowance = await this.state.contracts.usdc.allowance(signerAddress, this.state.contracts.vault.address);
                    if (allowance.lt(usdcAmount)) {
                        this.showStatus("Wymagana akceptacja USDC...", "loading");
                        const txApprove = await this.state.contracts.usdc.approve(this.state.contracts.vault.address, ethers.constants.MaxUint256);
                        await txApprove.wait();
                    }
                    this.showStatus("Realizowanie przelewu...", "loading");
                    const tx = await this.state.contracts.vault.transferToFund(usdcAmount);
                    await tx.wait();
                    this.showStatus("Przelew zakończony sukcesem!", "success");
                    this.updateUI();
                } catch (error) {
                console.error("Błąd podczas przelewu do skarbca:", error);
                this.showStatus("Błąd przelewu. Sprawdź konsolę.", "error");
                }
            }

            async handleTransferFromFund() {
                const amount = this.elements.transferFromFund.value;
                if (!amount || isNaN(amount) || amount <= 0) {
                    this.showStatus("Podaj poprawną kwotę.", "error");
                    return;
                }
                this.showStatus("Przelewanie ze skarbca...", "loading");
                try {
                    const usdcAmount = ethers.utils.parseUnits(amount, 6);
                    const tx = await this.state.contracts.vault.transferFromFund(usdcAmount);
                    await tx.wait();
                    this.showStatus("Przelew zakończony sukcesem!", "success");
                    this.updateUI();
                } catch (error) {
                    console.error("Błąd podczas przelewu ze skarbca:", error);
                    this.showStatus("Błąd przelewu. Sprawdź konsolę.", "error");
                }
            }

            // Poprawiona funkcja loadWithdrawalRequestsHistory
            async loadWithdrawalRequestsHistory() {
                this.showStatus("Ładowanie historii wniosków...", "loading");
                try {
                    const provider = this.state.provider;
                    if (!provider) {
                        this.showStatus("Provider nie jest dostępny.", "error");
                        return;
                    }

                    // Fetch all events
                    const requestedEvents = await this.state.contracts.vault.queryFilter('DelayedWithdrawalRequested', 0, 'latest');
                    const fulfilledEvents = await this.state.contracts.vault.queryFilter('DelayedWithdrawalFulfilled', 0, 'latest');
                    const canceledEvents = await this.state.contracts.vault.queryFilter('DelayedWithdrawalCanceled', 0, 'latest');

                    // Combine all events and add a type for differentiation
                    const allEvents = [
                        ...requestedEvents.map(ev => ({ ...ev, type: 'requested' })),
                        ...fulfilledEvents.map(ev => ({ ...ev, type: 'fulfilled' })),
                        ...canceledEvents.map(ev => ({ ...ev, type: 'canceled' }))
                    ];

                    // Sort chronologically (by blockNumber, then transactionIndex)
                    allEvents.sort((a, b) => {
                        if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber;
                        return a.transactionIndex - b.transactionIndex;
                    });

                    const requests = new Map();
                    const lastRequestPerUser = new Map();
                    
                    for (const event of allEvents) {
                        const { client } = event.args;
                        if (event.type === 'requested') {
                            const { assetsToRedeem, unlockTime } = event.args;
                            const reqId = event.transactionHash;
                            const block = await provider.getBlock(event.blockNumber);
                            const req = {
                                id: reqId,
                                user: client,
                                assets: assetsToRedeem,
                                unlockTime,
                                status: 'pending',
                                eventBlockTimestamp: block.timestamp,
                                event: event
                            };
                            requests.set(reqId, req);
                            lastRequestPerUser.set(client, reqId);
                        } else if (event.type === 'fulfilled' || event.type === 'canceled') {
                            const lastReqId = lastRequestPerUser.get(client);
                            if (lastReqId) {
                                const req = requests.get(lastReqId);
                                if (req && req.status === 'pending') {
                                    req.status = event.type === 'fulfilled' ? 'fulfilled' : 'canceled';
                                }
                                lastRequestPerUser.delete(client);
                            }
                        }
                    }

                    // Filter requests from the last 60 days
                    const sixtyDaysAgo = Math.floor(Date.now() / 1000) - (60 * 24 * 3600);
                    const filteredRequests = Array.from(requests.values()).filter(req => req.eventBlockTimestamp >= sixtyDaysAgo);

                    // Sort by blockNumber descending (newest first)
                    const sortedRequests = filteredRequests.sort((a, b) => b.event.blockNumber - a.event.blockNumber);
                    
                    // Clear UI lists
                    const lists = {
                        unclaimed: this.elements.unclaimedRequestsList,
                        pending: this.elements.pendingRequestsList,
                        archived: this.elements.archivedRequestsList
                    };
                    Object.values(lists).forEach(list => list.innerHTML = '');

                    const now = Math.floor(Date.now() / 1000);

                    sortedRequests.forEach(req => {
                        const isReady = req.unlockTime.toNumber() <= now;
                        let targetList;

                        if (req.status === 'pending' && isReady) {
                            req.status = 'ready'; // Ready for claim
                            targetList = lists.unclaimed;
                        } else if (req.status === 'pending' && !isReady) {
                            targetList = lists.pending;
                        } else {
                            targetList = lists.archived;
                        }

                        targetList.appendChild(this.createRequestListItem(req));
                    });
                    
                    Object.values(lists).forEach((list, index) => {
                        if (list.children.length === 0) {
                            const messages = ['Brak wniosków do odbioru.', 'Brak oczekujących wniosków.', 'Brak zakończonych wniosków.'];
                            list.innerHTML = `<li class="text-gray-500 text-center py-2">${messages[index]}</li>`;
                        }
                    });

                    this.hideStatus();
                } catch (error) {
                    console.error("Błąd podczas pobierania historii wniosków:", error);
                    this.showStatus("Błąd ładowania historii", "error");
                }
            }
            
            createRequestListItem(req) {
                const li = document.createElement('li');
                const isReady = req.unlockTime.toNumber() <= Math.floor(Date.now() / 1000);
                let statusText = 'Oczekujący';
                let statusColorClass = 'list-item-pending';
                let buttonHtml = '';
                
                if (req.status === 'fulfilled') {
                    statusText = 'Zrealizowany';
                    statusColorClass = 'list-item-archived';
                } else if (req.status === 'canceled') {
                    statusText = 'Anulowany';
                    statusColorClass = 'list-item-archived';
                } else if (req.status === 'ready') {
                    statusText = 'Gotowy do odbioru';
                    statusColorClass = 'list-item-ready';
                    buttonHtml = `<button class="btn btn-blue w-auto whitespace-nowrap px-4 py-2 mt-2" onclick="app.handleFulfillWithdrawal('${req.user}')">Wypłać</button>`;
                }

                const assetsFormatted = ethers.utils.formatUnits(req.assets, 6);
                const unlockTime = new Date(req.unlockTime.toNumber() * 1000).toLocaleString();
                const remainingTime = Math.max(0, req.unlockTime.toNumber() - Math.floor(Date.now() / 1000));
                const remainingTimeText = remainingTime > 0 ? `(${remainingTime}s pozostało)` : '';
                
                li.className = `list-item ${statusColorClass}`;
                li.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <p class="font-bold">${assetsFormatted} USDC</p>
                            <p class="text-sm text-gray-400">Adres klienta: <span class="break-all">${req.user}</span></p>
                            <p class="text-sm text-gray-400">Odblokowanie: ${unlockTime} ${remainingTimeText}</p>
                            <p class="text-sm">Status: <span class="font-semibold">${statusText}</span></p>
                        </div>
                        <div>
                            ${buttonHtml}
                        </div>
                    </div>
                `;
                return li;
            }

            switchTab(tab) {
                if (tab === 'instant') {
                    this.elements.tabInstant.classList.replace('tab-inactive', 'tab-active');
                    this.elements.tabDelayed.classList.replace('tab-active', 'tab-inactive');
                    this.elements.instantWithdrawPanel.classList.remove('hidden');
                    this.elements.delayedWithdrawPanel.classList.add('hidden');
                } else {
                    this.elements.tabInstant.classList.replace('tab-active', 'tab-inactive');
                    this.elements.tabDelayed.classList.replace('tab-inactive', 'tab-active');
                    this.elements.instantWithdrawPanel.classList.add('hidden');
                    this.elements.delayedWithdrawalPanel.classList.remove('hidden');
                }
            }

            showStatus(message, type = "info") {
                this.elements.statusText.innerText = message;
                const statusDiv = this.elements.statusMessage;
                statusDiv.classList.remove('hidden');
                statusDiv.className = 'fixed bottom-5 right-5 p-4 rounded-lg shadow-lg max-w-sm border-l-4';
                if (type === 'loading') {
                    this.elements.statusSpinner.classList.remove('hidden');
                    statusDiv.classList.add('bg-blue-900', 'border-blue-500');
                } else {
                    this.elements.statusSpinner.classList.add('hidden');
                    if (type === 'success') statusDiv.classList.add('bg-green-900', 'border-green-500');
                    else if (type === 'error') statusDiv.classList.add('bg-red-900', 'border-red-500');
                    else statusDiv.classList.add('bg-gray-800', 'border-gray-500');
                }
            }

            hideStatus() {
                setTimeout(() => {
                    this.elements.statusMessage.classList.add('hidden');
                }, 3000);
            }
        }

        window.onload = () => {
            window.app = new DApp();
            app.init();
        };
    </script>
</body>
</html>

